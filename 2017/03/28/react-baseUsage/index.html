<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Na Yang">
  <!-- Open Graph Data -->
  <meta property="og:title" content="react_baseUsage"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="Hexo"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.comundefined"/>
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>Hexo</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>

  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">react_baseUsage</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://yangna0420.github.io.git">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="/yangnaupc@126.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>


<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By Na Yang</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">2017-03-28</span>
            <span class="time">19:51:38</span>
          </span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/react-component/">#react component</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <p>​    React是什么？React是Facebook开源的一个用于构建用户界面的Javascript库，已经 应用于Facebook及旗下Instagram。和庞大的AngularJS不同，React专注于MVC架构中的V，即视图。 这使得React很容易和开发者已有的开发栈进行融合。React顺应了Web开发组件化的趋势。</p>
<a id="more"></a>
<p>​    应用React时，你总是应该从UI出发抽象出不同 的组件，然后像搭积木一样把它们拼装起来;这个项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案。衍生的 React Native 项目，目标更是宏伟，希望用写 Web App 的方式去写 Native App。如果能够实现，整个互联网行业都会被颠覆，因为同一组人只需要写一次 UI ，就能同时运行在服务器、浏览器和手机应。</p>
<h1 id="初识React及其基本应用"><a href="#初识React及其基本应用" class="headerlink" title="初识React及其基本应用"></a>初识React及其基本应用</h1><h2 id="为什么使用-React"><a href="#为什么使用-React" class="headerlink" title="为什么使用 React?"></a>为什么使用 React?</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">我们创造 React 是为了解决一个问题：构建随着时间数据不断变化的大规模应用程序。为了达到这个目标，React 采用下面两个主要的思想。</div><div class="line">1、简单 </div><div class="line">仅仅只要表达出你的应用程序在任一个时间点应该长的样子，然后当底层的数据变了，React 会自动处理所有用户界面的更新。</div><div class="line">2、声明式 (Declarative) </div><div class="line">数据变化后，React 概念上与点击“刷新”按钮类似，但仅会更新变化的部分。</div><div class="line">3、构建可组合的组件 </div><div class="line">React 都是关于构建可复用的组件。事实上，通过 React 你唯一要做的事情就是构建组件。得益于其良好的封装性，组件使代码复用、测试和关注分离（separation of concerns）更加简单。</div></pre></td></tr></table></figure>
<h2 id="官网地址"><a href="#官网地址" class="headerlink" title="官网地址"></a>官网地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">英文网：http://facebook.github.io/react/docs/getting-started.html</div><div class="line">文档最新且更新快（推荐大家看这个）</div><div class="line">中文网：http://reactjs.cn/react/docs/getting-started.html</div><div class="line">文档陈旧版本低（大家如果看不懂英文可以先看这个）</div></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">· Props（属性，就是element上的attrs，换个名字property，变成复数，即props）</div><div class="line"></div><div class="line">· State（写过view组件的基本都会知道，按钮有三态，Normal，Highlight，Selected，包括extjs，jquery里的大部分ui框架都是有状态的。）</div></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。</div><div class="line"></div><div class="line">· componentWillMount()</div><div class="line"></div><div class="line">· componentDidMount()</div><div class="line"></div><div class="line">· componentWillUpdate(object nextProps, object nextState)</div><div class="line"></div><div class="line">· componentDidUpdate(object prevProps, object prevState)</div><div class="line"></div><div class="line">· componentWillUnmount()</div><div class="line"></div><div class="line">此外，React 还提供两种特殊状态的处理函数。</div><div class="line"></div><div class="line">· componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用</div><div class="line"></div><div class="line">· shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用</div></pre></td></tr></table></figure>
<h2 id="函数调用顺序图"><a href="#函数调用顺序图" class="headerlink" title="函数调用顺序图"></a>函数调用顺序图</h2><p><img src="E:\杨娜博客\blog\my_img\wps6AA7.tmp.jpg" alt="wps6AA7.tmp"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">从上图中我们可以看出来，组件再初始化一次之后就不会再运行上图运行中文字以上的方法，反而里面会有事件监听，从而执行shouleComponentUpdate事件。</div></pre></td></tr></table></figure>
<h2 id="代码使用"><a href="#代码使用" class="headerlink" title="代码使用"></a>代码使用</h2><h3 id="ES5写法"><a href="#ES5写法" class="headerlink" title="ES5写法"></a>ES5写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var Hello = React.createClass(&#123;</div><div class="line"></div><div class="line">    getInitialState() &#123;</div><div class="line"></div><div class="line">        return &#123; liked: false &#125;;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    render: function() &#123;</div><div class="line"></div><div class="line">        console.log(this.state.liked);</div><div class="line"></div><div class="line">        return(</div><div class="line"></div><div class="line">            &lt;div&gt;</div><div class="line"></div><div class="line">                &lt;h1 style=&#123;style&#125;&gt;Hello world&lt;/h1&gt;</div><div class="line"></div><div class="line">                &lt;br/&gt;</div><div class="line"></div><div class="line">                &lt;image/&gt;</div><div class="line"></div><div class="line">            &lt;/div&gt;</div><div class="line"></div><div class="line">        )</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">module.exports=Hello;</div></pre></td></tr></table></figure>
<h3 id="ES6写法"><a href="#ES6写法" class="headerlink" title="ES6写法"></a>ES6写法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">export default class Hello extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line"></div><div class="line">        this.state = &#123; count: &apos;es6&apos;&#125;;</div><div class="line">    &#125;</div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt;</div><div class="line">                &lt;br/&gt;</div><div class="line">                &lt;image/&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">生命周期详细介绍：</div><div class="line">	http://www.cnblogs.com/CHONGCHONG2008/p/5099483.html</div><div class="line">	http://pinggod.com/2015/React-%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</div><div class="line">	http://reactjs.cn/react/docs/component-specs.html</div></pre></td></tr></table></figure>
<h4 id="5-ES6最新写法对照表"><a href="#5-ES6最新写法对照表" class="headerlink" title="5/ES6最新写法对照表"></a>5/ES6最新写法对照表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">React的：</div><div class="line">http://www.tuicool.com/articles/equ2my</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ReactNative的</div><div class="line">http://bbs.reactnative.cn/topic/15/react-react-native-%E7%9A%84es5-es6%E5%86%99%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8/2</div></pre></td></tr></table></figure>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><h3 id="1-0-使用"><a href="#1-0-使用" class="headerlink" title="1.0    使用"></a>1.0    使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">onClick这种进行驼峰命名ES5和ES6的写法不一样，在ES6中要用bind方法绑定this(具体可参照ES5和ES6写法对照表)</div><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line">import &#123; render &#125; from &apos;react-dom&apos;;</div><div class="line"></div><div class="line">export default class LinkButton extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        this.state = &#123;liked: false&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(e) &#123;</div><div class="line">        this.setState(&#123; liked: !this.state.liked &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        const text = this.state.liked ? &apos;like&apos; : &apos;haven\&apos;t liked&apos;;</div><div class="line">        return (</div><div class="line">            &lt;p onClick=&#123;this.handleClick.bind(this)&#125;&gt;</div><div class="line">                You &#123;text&#125; this. Click to toggle.</div><div class="line">            &lt;/p&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-0-参数传递"><a href="#2-0-参数传递" class="headerlink" title="2.0    参数传递"></a>2.0    参数传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">ES6写法：给事件处理函数传递额外参数的方式：bind(this, arg1, arg2, ...)</div><div class="line"></div><div class="line">render: function() &#123;</div><div class="line">    return &lt;p onClick=&#123;this.handleClick.bind(this, param1,param2,param3)&#125;&gt;;</div><div class="line">&#125;,</div><div class="line">handleClick: function(param1,param2,param3, event) &#123;</div><div class="line">    // handle click</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-0-React-支持的事件列表"><a href="#3-0-React-支持的事件列表" class="headerlink" title="3.0    React 支持的事件列表"></a>3.0    React 支持的事件列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://reactjs.cn/react/docs/events.html</div></pre></td></tr></table></figure>
<h2 id="Dom操作"><a href="#Dom操作" class="headerlink" title="Dom操作"></a>Dom操作</h2><h3 id="1-0-方法一：findDOMNode-方法（了解）"><a href="#1-0-方法一：findDOMNode-方法（了解）" class="headerlink" title="1.0    方法一：findDOMNode()方法（了解）"></a>1.0    方法一：findDOMNode()方法（了解）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">首先我们要了解 ReactDOM.render 组件返回的是对组件的引用也就是组件实例（对于无状态状态组件来说返回 null），注意 JSX 返回的不是组件实例，它只是一个 ReactElement 对象。</div><div class="line"></div><div class="line">当组件加载到页面上之后（mounted），你都可以通过 react-dom 提供的 findDOMNode() 方法拿到组件对应的 DOM 元素。</div><div class="line"></div><div class="line">import &#123; findDOMNode &#125; from &apos;react-dom&apos;;</div><div class="line"></div><div class="line">// Inside Component class</div><div class="line">componentDidMound() &#123;</div><div class="line">  const el = findDOMNode(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">findDOMNode() 不能用在无状态组件上。</div></pre></td></tr></table></figure>
<h3 id="2-0-方法二：refs属性"><a href="#2-0-方法二：refs属性" class="headerlink" title="2.0    方法二：refs属性"></a>2.0    方法二：refs属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">另外一种方式就是通过在要引用的 DOM 元素上面设置一个 ref 属性指定一个名称，然后通过 this.refs.name 来访问对应的 DOM 元素。</div><div class="line"></div><div class="line">如果 ref 是设置在原生 HTML 元素上，它拿到的就是 DOM 元素，如果设置在自定义组件上，它拿到的就是组件实例，这时候就需要通过 findDOMNode 来拿到组件的 DOM 元素。</div><div class="line"></div><div class="line">因为无状态组件没有实例，所以 ref 不能设置在无状态组件上，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 ref 去拿实例调用相关的方法，但是如果想要拿无状态组件的 DOM 元素的时候，就需要用一个状态组件封装一层，然后通过 ref 和 findDOMNode 去获取。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div><div class="line"></div><div class="line">export default class MyInputFocus extends Component &#123;</div><div class="line">    constructor(props) &#123;</div><div class="line">        super(props);</div><div class="line">        this.state=&#123; userInput: &apos;&apos; &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChange(e) &#123;</div><div class="line">        console.log(this.refs.theInput.value);</div><div class="line">        this.setState(&#123; userInput: e.target.value &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    clearAndFocusInput() &#123;</div><div class="line">        this.setState(&#123; userInput: &apos;&apos; &#125;, () =&gt; &#123;</div><div class="line">            this.refs.theInput.focus();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;div&gt;</div><div class="line">                &lt;div onClick=&#123;this.clearAndFocusInput.bind(this)&#125;&gt;</div><div class="line">                Click to Focus and Reset</div><div class="line">                &lt;/div&gt;</div><div class="line">                &lt;input</div><div class="line">                    ref=&quot;theInput&quot;</div><div class="line">                    value=&#123;this.state.userInput&#125;</div><div class="line">                    onChange=&#123;this.handleChange.bind(this)&#125;</div><div class="line">                /&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">MyInputFocus.defaultProps=&#123;</div><div class="line">    autoPlay:false,</div><div class="line">    maxLoops:10,</div><div class="line">&#125;</div><div class="line">MyInputFocus.propTypes = &#123;</div><div class="line">    autoPlay: React.PropTypes.bool.isRequired,</div><div class="line">    maxLoops: React.PropTypes.number.isRequired,</div></pre></td></tr></table></figure>
<h3 id="3-0-注意事项"><a href="#3-0-注意事项" class="headerlink" title="3.0    注意事项"></a>3.0    注意事项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*你可以使用 ref 到的组件定义的任何公共方法，比如 this.refs.myTypeahead.reset()</div><div class="line">*Refs 是访问到组件内部 DOM 节点唯一可靠的方法</div><div class="line">*Refs 会自动销毁对子组件的引用（当子组件删除时）</div><div class="line">*不要在 render 或者 render 之前访问 refs</div><div class="line">*不要滥用 refs，比如只是用它来按照传统的方式操作界面 UI：找到 DOM -&gt; 更新 DOM</div></pre></td></tr></table></figure>
<h2 id="和其他库配合使用"><a href="#和其他库配合使用" class="headerlink" title="和其他库配合使用"></a>和其他库配合使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://reactjs.cn/react/tips/use-react-with-other-libraries.html</div></pre></td></tr></table></figure>
<h2 id="组件的-DOM-事件监听"><a href="#组件的-DOM-事件监听" class="headerlink" title="组件的 DOM 事件监听"></a>组件的 DOM 事件监听</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">这篇文章是讲如何给 DOM 元素绑定 React 未提供的事件</div><div class="line"></div><div class="line">var Box = React.createClass(&#123;</div><div class="line">  getInitialState: function() &#123;</div><div class="line">    return &#123;windowWidth: window.innerWidth&#125;;</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  handleResize: function(e) &#123;</div><div class="line">    this.setState(&#123;windowWidth: window.innerWidth&#125;);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  componentDidMount: function() &#123;</div><div class="line">    window.addEventListener(&apos;resize&apos;, this.handleResize);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  componentWillUnmount: function() &#123;</div><div class="line">    window.removeEventListener(&apos;resize&apos;, this.handleResize);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  render: function() &#123;</div><div class="line">    return &lt;div&gt;Current window width: &#123;this.state.windowWidth&#125;&lt;/div&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">React.render(&lt;Box /&gt;, mountNode);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://reactjs.cn/react/tips/dom-event-listeners.html</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1、注意添加dom事件的位置</div><div class="line">2、在组件退出的时候，取消监听事件</div></pre></td></tr></table></figure>
<h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://facebook.github.io/react/tips/initial-ajax.html</div></pre></td></tr></table></figure>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">表单不同于其他 HTML 元素，因为它要响应用户的交互，显示不同的状态，所以在 React 里面会有点特殊。</div></pre></td></tr></table></figure>
<h3 id="1-0-状态属性"><a href="#1-0-状态属性" class="headerlink" title="1.0    状态属性"></a>1.0    状态属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">表单元素有这么几种属于状态的属性：</div><div class="line">value，对应 &lt;input&gt; 和 &lt;textarea&gt; 所有</div><div class="line">checked，对应类型为 checkbox 和 radio 的 &lt;input&gt; 所有</div><div class="line">selected，对应 &lt;option&gt; 所有</div><div class="line">在 HTML 中 &lt;textarea&gt; 的值可以由子节点（文本）赋值，但是在 React 中，要用 value 来设置。</div><div class="line">表单元素包含以上任意一种状态属性都支持 onChange 事件监听状态值的更改。</div><div class="line">针对这些状态属性不同的处理策略，表单元素在 React 里面有两种表现形式。</div></pre></td></tr></table></figure>
<h3 id="2-0-受控组件"><a href="#2-0-受控组件" class="headerlink" title="2.0    受控组件"></a>2.0    受控组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">对于设置了上面提到的对应“状态属性“值的表单元素就是受控表单组件，比如：</div><div class="line">render: function() &#123;</div><div class="line">    return &lt;input type=&quot;text&quot; value=&quot;hello&quot;/&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">一个受控的表单组件，它所有状态属性更改涉及 UI 的变更都由 React 来控制（状态属性绑定 UI）。比如上面代码里的 &lt;input&gt; 输入框，用户输入内容，用户输入的内容不会显示（输入框总是显示状态属性 value 的值 hello），这有点颠覆我们的认知了，所以说这是受控组件，不是原来默认的表单元素了。</div><div class="line">如果你希望输入的内容反馈到输入框，就要用 onChange 事件改变状态属性 value 的值：</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">getInitialState: function() &#123;</div><div class="line">    return &#123;value: &apos;hello&apos;&#125;;</div><div class="line">&#125;,</div><div class="line">handleChange: function(event) &#123;</div><div class="line">    this.setState(&#123;value: event.target.value&#125;);</div><div class="line">&#125;,</div><div class="line">render: function() &#123;</div><div class="line">    var value = this.state.value;</div><div class="line">    return &lt;input type=&quot;text&quot; value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt;;</div><div class="line">&#125;</div><div class="line">使用这种模式非常容易实现类似对用户输入的验证，或者对用户交互做额外的处理，比如截断最多输入140个字符：</div><div class="line">handleChange: function(event) &#123;</div><div class="line">    this.setState(&#123;value: event.target.value.substr(0, 140)&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-0-非受控属性"><a href="#3-0-非受控属性" class="headerlink" title="3.0    非受控属性"></a>3.0    非受控属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">和受控组件相对，如果表单元素没有设置自己的“状态属性”，或者属性值设置为 null，这时候就是非受控组件。</div><div class="line">它的表现就符合普通的表单元素，正常响应用户的操作。</div><div class="line">同样，你也可以绑定 onChange 事件处理交互。</div><div class="line">如果你想要给“状态属性”设置默认值，就要用 React 提供的特殊属性 defaultValue，对于 checked 会有 defaultChecked，&lt;option&gt; 也是使用 defaultValue。</div></pre></td></tr></table></figure>
<h3 id="4-0-为什么要有受控组件"><a href="#4-0-为什么要有受控组件" class="headerlink" title="4.0    为什么要有受控组件"></a>4.0    为什么要有受控组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">引入受控组件不是说它有什么好处，而是因为 React 的 UI 渲染机制，对于表单元素不得不引入这一特殊的处理方式。</div><div class="line">在浏览器 DOM 里面是有区分 attribute 和 property 的。attribute 是在 HTML 里指定的属性，而每个 HTML 元素在 JS 对应是一个 DOM 节点对象，这个对象拥有的属性就是 property（可以在 console 里展开一个 DOM 节点对象看一下，HTML attributes 只是对应其中的一部分属性），attribute 对应的 property 会从 attribute 拿到初始值，有些会有相同的名称，但是有些名称会不一样，比如 attribute class 对应的 property 就是 className。（详细解释：.prop，.prop() vs .attr()）回到 React 里的 &lt;input&gt; 输入框，当用户输入内容的时候，输入框的 value property 会改变，但是 value attribute 依然会是 HTML 上指定的值（attribute 要用 setAttribute 去更改）。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">React 组件必须呈现这个组件的状态视图，这个视图 HTML 是由 render 生成，所以对于</div><div class="line">render: function() &#123;</div><div class="line">    return &lt;input type=&quot;text&quot; value=&quot;hello&quot;/&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">在任意时刻，这个视图总是返回一个显示 hello 的输入框。</div></pre></td></tr></table></figure>
<h3 id="5-0-的处理"><a href="#5-0-的处理" class="headerlink" title="5.0     的处理"></a>5.0     <select>的处理</select></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">	在 HTML 中 &lt;select&gt; 标签指定选中项都是通过对应 &lt;option&gt; 的 selected 属性来做的，但是在 React 修改成统一使用 value。</div><div class="line">	所以没有一个 selected 的状态属性。</div><div class="line">&lt;select value=&quot;B&quot;&gt;</div><div class="line">    &lt;option value=&quot;A&quot;&gt;Apple&lt;/option&gt;</div><div class="line">    &lt;option value=&quot;B&quot;&gt;Banana&lt;/option&gt;</div><div class="line">    &lt;option value=&quot;C&quot;&gt;Cranberry&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">你可以通过传递一个数组指定多个选中项：&lt;select multiple=&#123;true&#125; value=&#123;[&apos;B&apos;, &apos;C&apos;]&#125;&gt;</div></pre></td></tr></table></figure>
<h2 id="参数传递的判断"><a href="#参数传递的判断" class="headerlink" title="参数传递的判断"></a>参数传递的判断</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://facebook.github.io/react/docs/transferring-props.html</div></pre></td></tr></table></figure>
<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用。</div><div class="line">在 React 组件中要包含其他组件作为子组件，只需要把组件当作一个 DOM 元素引入就可以了。</div><div class="line"></div><div class="line">http://reactjs.cn/react/docs/multiple-components.html</div></pre></td></tr></table></figure>
<h3 id="1-0循环插入子元素"><a href="#1-0循环插入子元素" class="headerlink" title="1.0循环插入子元素"></a>1.0循环插入子元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">如果组件中包含通过循环插入的子元素，为了保证重新渲染 UI 的时候能够正确显示这些子元素，每个元素都需要通过一个特殊的 key 属性指定一个唯一值。为了内部 diff 的效率。</div><div class="line"></div><div class="line">var TodoList = React.createClass(&#123;</div><div class="line">    render: function() &#123;</div><div class="line">        var createItem = function(item) &#123;</div><div class="line">            return &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;;</div><div class="line">        &#125;;</div><div class="line">        return &lt;ul&gt;&#123;this.props.items.map(createItem)&#125;&lt;/ul&gt;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">module.export=TodoList</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">（1）当 React 校正带有 key 的子级时，它会确保它们被重新排序（而不是破坏）或者删除（而不是重用）。 务必 把 key 添加到子级数组里组件本身上，而不是每个子级内部最外层 HTML 上。</div><div class="line">（2）也可以传递 object 来做有 key 的子级。object 的 key 会被当作每个组件的 key。但是一定要牢记 JavaScript 并不总是保证属性的顺序会被保留。实际情况下浏览器一般会保留属性的顺序，除了 使用 32位无符号数字做为 key 的属性。数字型属性会按大小排序并且排在其它属性前面。一旦发生这种情况，React 渲染组件的顺序就是混乱。可能在 key 前面加一个字符串前缀来避免：</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">render: function() &#123;</div><div class="line">    var items = &#123;&#125;;</div><div class="line"></div><div class="line">    this.props.results.forEach(function(result) &#123;</div><div class="line">      // 如果 result.id 看起来是一个数字（比如短哈希），那么</div><div class="line">      // 对象字面量的顺序就得不到保证。这种情况下，需要添加前缀</div><div class="line">      // 来确保 key 是字符串。</div><div class="line">      items[&apos;result-&apos; + result.id] = &lt;li&gt;&#123;result.text&#125;&lt;/li&gt;;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    return (</div><div class="line">      &lt;ol&gt;</div><div class="line">        &#123;items&#125;</div><div class="line">      &lt;/ol&gt;</div><div class="line">    );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="2-0子级"><a href="#2-0子级" class="headerlink" title="2.0子级"></a>2.0子级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">组件标签里面包含的子元素会通过父元素的props.children 传递进来。</div><div class="line">HTML 元素会作为 React 组件对象、JS 表达式结果是一个文字节点，都会存入 Parent 组件的 props.children。</div><div class="line">props.children 通常是一个组件对象的数组，但是当只有一个子元素的时候，props.children 将是这个唯一的子元素，而不是数组了</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var NotesList = React.createClass(&#123;</div><div class="line">  render: function() &#123;</div><div class="line">    return (</div><div class="line">      &lt;ol&gt;</div><div class="line">      &#123;</div><div class="line">        React.Children.map(this.props.children, function (child) &#123;</div><div class="line">          return &lt;li&gt;&#123;child&#125;&lt;/li&gt;;</div><div class="line">        &#125;)</div><div class="line">      &#125;</div><div class="line">      &lt;/ol&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;NotesList&gt;</div><div class="line">    &lt;span&gt;hello&lt;/span&gt;</div><div class="line">    &lt;span&gt;world&lt;/span&gt;</div><div class="line">  &lt;/NotesList&gt;,</div><div class="line">  document.body</div><div class="line">);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">上面代码的 NoteList 组件有两个 span 子节点，它们都可以通过 this.props.children 读取，运行结果如下:</div><div class="line"></div><div class="line">1. hello</div><div class="line">2. world</div><div class="line"></div><div class="line">这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。</div><div class="line">React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。https://facebook.github.io/react/docs/top-level-api.html</div></pre></td></tr></table></figure>
<h2 id="propsType"><a href="#propsType" class="headerlink" title="propsType"></a>propsType</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://www.reactjs.cn/react/docs/reusable-components.html</div></pre></td></tr></table></figure>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://facebook.github.io/react/docs/context.html</div></pre></td></tr></table></figure>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">http://facebook.github.io/react/docs/animation.html</div><div class="line">http://blog.csdn.net/lihongxun945/article/details/46778723</div><div class="line">https://zhuanlan.zhihu.com/p/20419592</div></pre></td></tr></table></figure>
<h2 id="获取react常用插件的网址"><a href="#获取react常用插件的网址" class="headerlink" title="获取react常用插件的网址"></a>获取react常用插件的网址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">https://js.coach/react/react-infinite</div><div class="line">https://react.parts/native</div></pre></td></tr></table></figure>

        </div>
      </div>
    </div>
  </div>
</article>



    <!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/levblanc">Levblanc.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

